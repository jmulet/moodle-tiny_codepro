{"version":3,"file":"htmlfy-lazy.min.js","sources":["../src/htmlfy-lazy.js"],"sourcesContent":["\n/** @ts-ignore */\n/* eslint-disable */\n\n/**\n * @type {import('htmlfy').Config}\n */\nconst CONFIG = {\n  content_wrap: 0,\n  ignore: [],\n  ignore_with: '_!i-£___£%_',\n  strict: false,\n  tab_size: 2,\n  tag_wrap: 0,\n  tag_wrap_width: 80,\n  trim: []\n};\n\nconst CONTENT_IGNORE_STRING = '__!i-£___£%__';\nconst IGNORE_STRING = '!i-£___£%_';\n\nconst VOID_ELEMENTS = [\n  'area', 'base', 'br', 'col', 'embed', 'hr', \n  'img', 'input', 'link', 'meta',\n  'param', 'source', 'track', 'wbr'\n];\n\n/**\n * Checks if content contains at least one HTML element or custom HTML element.\n * \n * The first regex matches void and self-closing elements.\n * The second regex matches normal HTML elements, plus they can have a namespace.\n * The third regex matches custom HTML elemtns, plus they can have a namespace.\n * \n * HTML elements should begin with a letter, and can end with a letter or number.\n * \n * Custom elements must begin with a letter, and can end with a letter, number,\n * hyphen, underscore, or period. However, all letters must be lowercase.\n * They must have at least one hyphen, and can only have periods and underscores if there is a hyphen.\n * \n * These regexes are based on\n * https://w3c.github.io/html-reference/syntax.html#tag-name\n * and\n * https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\n * respectively.\n * \n * @param {string} content Content to evaluate.\n * @returns {boolean} A boolean.\n */\nconst isHtml = (content) => \n  /<(?:[A-Za-z]+[A-Za-z0-9]*)(?:\\s+.*?)*?\\/{0,1}>/.test(content) ||\n  /<(?<Element>(?:[A-Za-z]+[A-Za-z0-9]*:)?(?:[A-Za-z]+[A-Za-z0-9]*))(?:\\s+.*?)*?>(?:.|\\n)*?<\\/{1}\\k<Element>>/.test(content) || \n  /<(?<Element>(?:[a-z][a-z0-9._]*:)?[a-z][a-z0-9._]*-[a-z0-9._-]+)(?:\\s+.*?)*?>(?:.|\\n)*?<\\/{1}\\k<Element>>/.test(content);\n\n/**\n * Generic utility which merges two objects.\n * \n * @param {any} current Original object.\n * @param {any} updates Object to merge with original.\n * @returns {any}\n */\nconst mergeObjects = (current, updates) => {\n  if (!current || !updates)\n    throw new Error(\"Both 'current' and 'updates' must be passed-in to mergeObjects()\")\n\n  /**\n   * @type {any}\n   */\n  let merged;\n  \n  if (Array.isArray(current)) {\n    merged = structuredClone(current).concat(updates);\n  } else if (typeof current === 'object') {\n    merged = { ...current };\n    for (let key of Object.keys(updates)) {\n      if (typeof updates[key] !== 'object') {\n        merged[key] = updates[key];\n      } else {\n        /* key is an object, run mergeObjects again. */\n        merged[key] = mergeObjects(merged[key] || {}, updates[key]);\n      }\n    }\n  }\n\n  return merged\n};\n\n/**\n * Merge a user config with the default config.\n * \n * @param {import('htmlfy').Config} dconfig The default config.\n * @param {import('htmlfy').UserConfig} config The user config.\n * @returns {import('htmlfy').Config}\n */\nconst mergeConfig = (dconfig, config) => {\n  /**\n   * We need to make a deep copy of `dconfig`,\n   * otherwise we end up altering the original `CONFIG` because `dconfig` is a reference to it.\n   */\n  return mergeObjects(structuredClone(dconfig), config)\n};\n\n/**\n * \n * @param {string} html \n */\nconst protectAttributes = (html) => {\n  html = html.replace(/<[\\w:\\-]+([^>]*[^\\/])>/g, (/** @type {string} */match, /** @type {any} */capture) => {\n    return match.replace(capture, (match) => {\n      return match\n        .replace(/\\n/g, IGNORE_STRING + 'nl!')\n        .replace(/\\r/g, IGNORE_STRING + 'cr!')\n        .replace(/\\s/g, IGNORE_STRING + 'ws!')\n    })\n  });\n\n  return html\n};\n\n/**\n * \n * @param {string} html \n */\nconst protectContent = (html) => {\n  return html\n    .replace(/\\n/g, CONTENT_IGNORE_STRING + 'nl!')\n    .replace(/\\r/g, CONTENT_IGNORE_STRING + 'cr!')\n    .replace(/\\s/g, CONTENT_IGNORE_STRING + 'ws!')\n};\n\n/**\n * \n * @param {string} html \n */\nconst finalProtectContent = (html) => {\n  const regex = /\\s*<([a-zA-Z0-9:-]+)[^>]*>\\n\\s*<\\/\\1>(?=\\n[ ]*[^\\n]*__!i-£___£%__[^\\n]*\\n)(\\n[ ]*\\S[^\\n]*\\n)|<([a-zA-Z0-9:-]+)[^>]*>(?=\\n[ ]*[^\\n]*__!i-£___£%__[^\\n]*\\n)(\\n[ ]*\\S[^\\n]*\\n\\s*)<\\/\\3>/g;\n  return html\n    .replace(regex, (/** @type {string} */match, p1, p2, p3, p4) => {\n      const text_to_protect = p2 || p4;\n\n      if (!text_to_protect)\n        return match\n\n      const protected_text = text_to_protect\n       .replace(/\\n/g, CONTENT_IGNORE_STRING + 'nl!')\n       .replace(/\\r/g, CONTENT_IGNORE_STRING + 'cr!')\n       .replace(/\\s/g, CONTENT_IGNORE_STRING + \"ws!\");\n\n      return match.replace(text_to_protect, protected_text)\n    })\n};\n\n/**\n * Replace html brackets with ignore string.\n * \n * @param {string} html \n * @returns {string}\n */\nconst setIgnoreAttribute = (html) => {\n  const regex = /<([A-Za-z][A-Za-z0-9]*|[a-z][a-z0-9._]*-[a-z0-9._-]+)((?:\\s+[A-Za-z0-9_-]+=\"[^\"]*\"|\\s*[a-z]*)*)>/g;\n\n  html = html.replace(regex, (/** @type {string} */match, p1, p2) => {\n    return match.replace(p2, (match) => {\n      return match\n        .replace(/</g, IGNORE_STRING + 'lt!')\n        .replace(/>/g, IGNORE_STRING + 'gt!')\n    })\n  });\n  \n  return html\n};\n\n/**\n * Trim leading and trailing whitespace characters.\n * \n * @param {string} html\n * @param {string[]} trim\n * @returns {string}\n */\nconst trimify = (html, trim) => {\n  for (let e = 0; e < trim.length; e++) {\n    /* Whitespace character must be escaped with '\\' or RegExp() won't include it. */\n    const leading_whitespace = new RegExp(`(<${trim[e]}[^>]*>)\\\\s+`, \"g\");\n    const trailing_whitespace = new RegExp(`\\\\s+(</${trim[e]}>)`, \"g\");\n\n    html = html\n      .replace(leading_whitespace, '$1')\n      .replace(trailing_whitespace, '$1');\n  }\n\n  return html\n};\n\n/**\n * \n * @param {string} html \n */\nconst unprotectAttributes = (html) => {\n  html = html.replace(/<[\\w:\\-]+([^>]*[^\\/])>/g, (/** @type {string} */match, /** @type {any} */capture) => {\n    return match.replace(capture, (match) => {\n      return match\n        .replace(new RegExp(IGNORE_STRING + 'nl!', \"g\"), '\\n')\n        .replace(new RegExp(IGNORE_STRING + 'cr!', \"g\"), '\\r')\n        .replace(new RegExp(IGNORE_STRING + 'ws!', \"g\"), ' ')\n    })\n  });\n\n  return html\n};\n\n/**\n * \n * @param {string} html \n */\nconst unprotectContent = (html) => {\n  html = html.replace(/.*__!i-£___£%__[a-z]{2}!.*/g, (/** @type {string} */match) => {\n    return match.replace(/__!i-£___£%__[a-z]{2}!/g, (match) => {\n      return match\n        .replace(new RegExp(CONTENT_IGNORE_STRING + 'nl!', \"g\"), '\\n')\n        .replace(new RegExp(CONTENT_IGNORE_STRING + 'cr!', \"g\"), '\\r')\n        .replace(new RegExp(CONTENT_IGNORE_STRING + 'ws!', \"g\"), ' ')\n    })\n  });\n\n  return html\n};\n\nconst escapedIgnoreString = IGNORE_STRING.replace(\n  /[-\\/\\\\^$*+?.()|[\\]{}]/g,\n  \"\\\\$&\"\n);\nconst ltPlaceholderRegex = new RegExp(escapedIgnoreString + \"lt!\", \"g\");\nconst gtPlaceholderRegex = new RegExp(escapedIgnoreString + \"gt!\", \"g\");\n\n/**\n * Replace ignore string with html brackets.\n * \n * @param {string} html \n * @returns {string}\n */\nconst unsetIgnoreAttribute = (html) => {\n  /* Regex to find opening tags and capture their attributes. */\n  const tagRegex = /<([\\w:\\-]+)([^>]*)>/g;\n\n  return html.replace(\n    tagRegex,\n    (\n      /** @type {string} */ fullMatch,\n      /** @type {string} */ tagName,\n      /** @type {string} */ attributesCapture\n    ) => {\n      const processedAttributes = attributesCapture\n        .replace(ltPlaceholderRegex, \"<\")\n        .replace(gtPlaceholderRegex, \">\");\n\n      /* Reconstruct the tag. */\n      return `<${tagName}${processedAttributes}>`\n    }\n  )\n};\n\n/**\n * Validate any passed-in config options and merge with CONFIG.\n * \n * @param {import('htmlfy').UserConfig} config A user config.\n * @returns {import('htmlfy').Config} A validated config.\n */\nconst validateConfig = (config) => {\n  if (typeof config !== 'object') throw new Error('Config must be an object.')\n\n  const config_empty = !(\n    Object.hasOwn(config, 'content_wrap') ||\n    Object.hasOwn(config, 'ignore') || \n    Object.hasOwn(config, 'ignore_with') || \n    Object.hasOwn(config, 'strict') || \n    Object.hasOwn(config, 'tab_size') || \n    Object.hasOwn(config, 'tag_wrap') || \n    Object.hasOwn(config, 'tag_wrap_width') || \n    Object.hasOwn(config, 'trim')\n  );\n\n  if (config_empty) return CONFIG\n\n  let tab_size = config.tab_size;\n\n  if (tab_size) {\n    if (typeof tab_size !== 'number') throw new Error(`tab_size must be a number, not ${typeof config.tab_size}.`)\n\n    const safe = Number.isSafeInteger(tab_size);\n    if (!safe) throw new Error(`Tab size ${tab_size} is not safe. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger for more info.`)\n\n    /** \n     * Round down, just in case a safe floating point,\n     * like 4.0, was passed.\n     */\n    tab_size = Math.floor(tab_size);\n    if (tab_size < 1 || tab_size > 16) throw new Error('Tab size out of range. Expecting 1 to 16.')\n  \n    config.tab_size = tab_size;\n  }\n\n  if (Object.hasOwn(config, 'content_wrap') && typeof config.content_wrap !== 'number')\n    throw new Error(`content_wrap config must be a number, not ${typeof config.tag_wrap_width}.`)\n\n  if (Object.hasOwn(config, 'ignore') && (!Array.isArray(config.ignore) || !config.ignore?.every((e) => typeof e === 'string')))\n    throw new Error('Ignore config must be an array of strings.')\n\n  if (Object.hasOwn(config, 'ignore_with') && typeof config.ignore_with !== 'string')\n    throw new Error(`Ignore_with config must be a string, not ${typeof config.ignore_with}.`)\n\n  if (Object.hasOwn(config, 'strict') && typeof config.strict !== 'boolean')\n    throw new Error(`Strict config must be a boolean, not ${typeof config.strict}.`)\n\n  /* TODO remove in v0.9.0 */\n  if (Object.hasOwn(config, 'tag_wrap') && typeof config.tag_wrap === 'boolean') {\n    console.warn('tag_wrap as a boolean is deprecated, and will not be supported in v0.9.0+. Use `tag_wrap: <number>` instead; where <number> is the max character width acceptable before wrapping attributes.');\n    if (config.tag_wrap_width)\n      config.tag_wrap = config.tag_wrap_width;\n    else\n      config.tag_wrap = CONFIG.tag_wrap_width;\n  }\n  \n  if (Object.hasOwn(config, 'tag_wrap') && typeof config.tag_wrap !== 'number')\n    throw new Error(`tag_wrap config must be a number, not ${typeof config.tag_wrap}.`)\n\n  /* TODO remove in v0.9.0 */\n  if (Object.hasOwn(config, 'tag_wrap_width'))\n    console.warn('tag_wrap_width is deprecated, and will not be supported in v0.9.0+. Use `tag_wrap: <number>` instead; where <number> is the max character width acceptable before wrapping attributes.');\n\n  /* TODO remove in v0.9.0 */\n  if (Object.hasOwn(config, 'tag_wrap_width') && typeof config.tag_wrap_width !== 'number')\n    throw new Error(`tag_wrap_width config must be a number, not ${typeof config.tag_wrap_width}.`)\n\n  if (Object.hasOwn(config, 'trim') && (!Array.isArray(config.trim) || !config.trim?.every((e) => typeof e === 'string')))\n    throw new Error('Trim config must be an array of strings.')\n\n  return mergeConfig(CONFIG, config)\n\n};\n\n/**\n * \n * @param {string} text \n * @param {number} width \n * @param {string} indent\n */\nconst wordWrap = (text, width, indent) => {\n  const words = text.trim().split(/\\s+/);\n  \n  if (words.length === 0 || (words.length === 1 && words[0] === ''))\n    return \"\"\n\n  const lines = [];\n  let current_line = \"\";\n  const padding_string = indent;\n\n  words.forEach((word) => {\n    if (word === \"\") return\n\n    if (word.length >= width) {\n      /* If there's content on the current line, push it first with correct padding. */\n      if (current_line !== \"\")\n        lines.push(lines.length === 0 ? indent + current_line : padding_string + current_line);\n\n      /* Push a long word on its own line with correct padding. */\n      lines.push(lines.length === 0 ? indent + word : padding_string + word);\n      current_line = \"\"; // Reset current line\n      return // Move to the next word\n    }\n\n    /* Check if adding the next word exceeds the wrap width. */\n    const test_line = current_line === \"\" ? word : current_line + \" \" + word;\n\n    if (test_line.length <= width) {\n      current_line = test_line;\n    } else {\n      /* Word doesn't fit, finish the current line and push it. */\n      if (current_line !== \"\") {\n         /* Add padding based on whether it's the first line added or not. */\n         lines.push(lines.length === 0 ? indent + current_line : padding_string + current_line);\n      }\n      /* Start a new line with the current word. */\n      current_line = word;\n    }\n  });\n\n  /* Add the last remaining line with appropriate padding. */\n  if (current_line !== \"\")\n    lines.push(lines.length === 0 ? indent + current_line : padding_string + current_line);\n\n  const result = lines.join(\"\\n\");\n\n  return protectContent(result)\n};\n\n/**\n * Extract any HTML blocks to be ignored,\n * and replace them with a placeholder\n * for re-insertion later.\n * \n * @param {string} html \n * @param {import('htmlfy').Config} config \n * @returns {{  html_with_markers: string, extracted_map: Map<any,any> }}\n */\nfunction extractIgnoredBlocks(html, config) {\n  let current_html = html;\n  const extracted_blocks = new Map();\n  let marker_id = 0;\n  const MARKER_PREFIX = \"___HTMLFY_SPECIAL_IGNORE_MARKER_\";\n\n  for (const tag of config.ignore) {\n    /* Ensure tag is escaped if it can contain regex special chars. */\n    const safe_tag_name = tag.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n\n    const regex = new RegExp(\n      `<${safe_tag_name}[^>]*>.*?<\\/${safe_tag_name}>`,\n      \"gs\" // global and dotAll\n    );\n\n    let match;\n    const replacements = []; // Store [startIndex, endIndex, marker]\n\n    while ((match = regex.exec(current_html)) !== null) {\n      const marker = `${MARKER_PREFIX}${marker_id++}___`;\n      extracted_blocks.set(marker, match[0]); // Store the full original match\n      replacements.push({\n        start: match.index,\n        end: regex.lastIndex,\n        marker: marker,\n      });\n    }\n\n    /* Apply replacements from the end to the beginning to keep indices valid. */\n    for (let i = replacements.length - 1; i >= 0; i--) {\n      const rep = replacements[i];\n      current_html =\n        current_html.substring(0, rep.start) +\n        rep.marker +\n        current_html.substring(rep.end);\n    }\n  }\n  return { html_with_markers: current_html, extracted_map: extracted_blocks }\n}\n\n/**\n * Re-insert ignored HTML blocks.\n * \n * @param {string} html_with_markers \n * @param {Map<any,any>} extracted_map \n * @returns \n */\nfunction reinsertIgnoredBlocks(html_with_markers, extracted_map) {\n  let final_html = html_with_markers;\n\n  for (const [marker, original_block] of extracted_map) {\n    final_html = final_html.split(marker).join(original_block);\n  }\n  return final_html\n}\n\n/**\n * Ensure void elements are \"self-closing\".\n * \n * @param {string} html The HTML string to evaluate.\n * @param {boolean} check_html Check to see if the content contains any HTML, before processing.\n * @returns {string}\n * @example <br> => <br />\n */\nconst closify = (html, check_html = true) => {\n  if (check_html && !isHtml(html)) return html\n  \n  return html.replace(/<([a-zA-Z\\-0-9:]+)[^>]*>/g, (match, name) => {\n    if (VOID_ELEMENTS.indexOf(name) > -1)\n      return (`${match.substring(0, match.length - 1)} />`).replace(/\\/\\s\\//g, '/')\n\n    return match.replace(/[\\s]?\\/>/g, `></${name}>`)\n  })\n};\n\n/**\n * Enforce entity characters for textarea content.\n * To also minifiy, pass `minify` as `true`.\n * \n * @param {string} html The HTML string to evaluate.\n * @param {boolean} [minify] Fully minifies the content of textarea elements. \n * Defaults to `false`. We recommend a value of `true` if you're running `entify()` \n * as a standalone function.\n * @returns {string}\n * @example <textarea>3 > 2</textarea> => <textarea>3 &gt; 2</textarea>\n */\nconst entify = (html, minify = false) => {\n  /** \n   * Use entities inside textarea content.\n   */\n  html = html.replace(/<textarea[^>]*>((.|\\n)*?)<\\/textarea>/g, (match, capture) => {\n    return match.replace(capture, (match) => {\n      return match\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&apos;')\n        .replace(/\\n/g, '&#10;')\n        .replace(/\\r/g, '&#13;')\n        .replace(/\\s/g, '&nbsp;')\n    })\n  });\n\n  /* Typical minification, but only for textareas. */\n  if (minify) {\n    html = html.replace(/<textarea[^>]*>((.|\\n)*?)<\\/textarea>/g, (match, capture) => {\n      /* Replace things inside the textarea content. */\n      match = match.replace(capture, (match) => {\n        return match\n          .replace(/\\n|\\t/g, '')\n          .replace(/[a-z]+=\"\\s*\"/ig, '')\n          .replace(/>\\s+</g, '><')\n          .replace(/\\s+/g, ' ')\n      });\n\n      /* Replace things in the entire element */\n      match = match\n        .replace(/\\s+/g, ' ')\n        .replace(/\\s>/g, '>')\n        .replace(/>\\s/g, '>')\n        .replace(/\\s</g, '<')\n        .replace(/class=[\"']\\s/g, (match) => match.replace(/\\s/g, ''))\n        .replace(/(class=.*)\\s([\"'])/g, '$1'+'$2');\n      return match\n    });\n  }\n\n  return html\n};\n\n/**\n * Creates a single-line HTML string\n * by removing line returns, tabs, and relevant spaces.\n * \n * @param {string} html The HTML string to minify.\n * @param {boolean} check_html Check to see if the content contains any HTML, before processing.\n * @returns {string} A minified HTML string.\n */\nconst minify = (html, check_html = true) => {\n  if (check_html && !isHtml(html)) return html\n\n  /**\n   * Ensure textarea content is specially minified and protected\n   * before general minification.\n   */\n  html = entify(html);\n\n  /* All other minification. */\n  // Remove ALL newlines and tabs explicitly.\n  html = html.replace(/\\n|\\t/g, '');\n\n  // Remove whitespace ONLY between tags.\n  html = html.replace(/>\\s+</g, \"><\");\n\n  // Collapse any remaining multiple spaces to single spaces.\n  html = html.replace(/ {2,}/g, ' ');\n\n  // Remove specific single spaces OR whitespace within closing tags.\n  html = html.replace(/ >/g, \">\");   // <tag > -> <tag>\n  html = html.replace(/ </g, \"<\");   // Text < -> Text< (Also handles leading space before tag)\n  html = html.replace(/> /g, \">\");   // > Text -> >Text\n  html = html.replace(/<\\s*\\//g, '</'); // < /tag -> </tag>\n\n  // Trim spaces around equals signs in attributes (run before value trim)\n  //    This handles `attr = \"value\"` -> `attr=\"value\"`\n  html = html.replace(/ = /g, \"=\");\n  // Consider safer alternatives if needed (e.g., / = \"/g, '=\"')\n\n  // Trim whitespace inside attribute values\n  html = html.replace(\n    /([a-zA-Z0-9_-]+)=(['\"])(.*?)\\2/g,\n    (match, attr_name, quote, value) => {\n      // value.trim() handles both leading/trailing spaces\n      // and cases where the value is only whitespace (becomes empty string)\n      const trimmed_value = value.trim();\n      return `${attr_name}=${quote}${trimmed_value}${quote}`\n    }\n  );\n\n  // Final trim for the whole string\n  html = html.trim();\n\n  return html\n};\n\n/**\n * @type {boolean}\n */\nlet strict;\n\n/**\n * @type {string[]}\n */\nlet trim;\n\n/**\n * @type {{ line: Record<string,string>[] }}\n */\nconst convert = {\n  line: []\n};\n\n/**\n * @type {Map<any,any>}\n */\nlet ignore_map;\n\n/**\n * Isolate tags, content, and comments.\n * \n * @param {string} html The HTML string to evaluate.\n * @returns {string}\n * @example <div>Hello World!</div> => \n *  [#-# : 0 : <div> : #-#]\n *  Hello World!\n *  [#-# : 1 : </div> : #-#]\n */\nconst enqueue = (html) => {\n  convert.line = [];\n  let i = -1;\n  /* Regex to find tags OR text content between tags. */\n  const regex = /(<[^>]+>)|([^<]+)/g;\n\n  html = html.replace(regex, (match, c1, c2) => {\n    if (c1) {\n      convert.line.push({ type: \"tag\", value: match });\n    } else if (c2 && c2.trim().length > 0) {\n      /* It's text content (and not just whitespace). */\n      convert.line.push({ type: \"text\", value: match });\n    }\n\n    i++;\n    return `\\n[#-# : ${i} : ${match} : #-#]\\n`\n  });\n\n  return html\n};\n\n/**\n * Preprocess the HTML.\n * \n * @param {string} html The HTML string to preprocess.\n * @returns {string}\n */\nconst preprocess = (html) => {\n  html = closify(html, false);\n\n  if (trim.length > 0) html = trimify(html, trim);\n\n  html = minify(html, false);\n  html = enqueue(html);\n\n  return html\n};\n\n/**\n * \n * @param {string} html The HTML string to process.\n * @param {import('htmlfy').Config} config \n * @returns {string}\n */\nconst process = (html, config) => {\n  const step = \" \".repeat(config.tab_size);\n  const tag_wrap = config.tag_wrap;\n  const content_wrap = config.content_wrap;\n  const ignore_with = config.ignore_with;\n  const placeholder_template = `-${ignore_with}`;\n\n  /* Track current number of indentations needed. */\n  let indents = '';\n\n  /** @type string[] */\n  const output_lines = [];\n  const tag_regex = /<[A-Za-z]+\\b[^>]*(?:.|\\n)*?\\/?>/g; /* Is opening tag or void element. */\n  const attribute_regex = /\\s{1}[A-Za-z-]+(?:=\".*?\")?/g; /* Matches all tag/element attributes. */\n\n  /* Process lines and indent. */\n  convert.line.forEach((source, index) => {\n    let current_line_value = source.value;\n\n    const is_ignored_content =\n      current_line_value.startsWith(placeholder_template + \"lt--\") ||\n      current_line_value.startsWith(placeholder_template + \"gt--\") ||\n      current_line_value.startsWith(placeholder_template + \"nl--\") ||\n      current_line_value.startsWith(placeholder_template + \"cr--\") ||\n      current_line_value.startsWith(placeholder_template + \"ws--\") ||\n      current_line_value.startsWith(placeholder_template + \"tab--\");\n\n    let subtrahend = 0;\n    const prev_line_data = convert.line[index - 1];\n    const prev_line_value = prev_line_data?.value ?? \"\"; // Use empty string if no prev line\n\n    /**\n     * Arbitratry character, to keep track of the string's length.\n     */\n    indents += '0';\n\n    if (index === 0) subtrahend++;\n    /* We're processing a closing tag. */\n    if (current_line_value.trim().startsWith(\"</\")) subtrahend++;\n    /* prevLine is a doctype declaration. */\n    if (prev_line_value.trim().startsWith(\"<!doctype\")) subtrahend++;\n    /* prevLine is a comment. */\n    if (prev_line_value.trim().startsWith(\"<!--\")) subtrahend++;\n    /* prevLine is a self-closing tag. */\n    if (prev_line_value.trim().endsWith(\"/>\")) subtrahend++;\n    /* prevLine is a closing tag. */\n    if (prev_line_value.trim().startsWith(\"</\")) subtrahend++;\n    /* prevLine is text. */\n    if (prev_line_data?.type === \"text\") subtrahend++;\n\n    /* Determine offset for line indentation. */\n    const offset = Math.max(0, indents.length - subtrahend);\n    /* Correct indent level for *this* line's content */\n    const current_indent_level = offset; // Store the level for this line\n\n    indents = indents.substring(0, current_indent_level); // Adjust for *next* round\n\n    /**\n     * Starts with a single punctuation character.\n     * Add punctuation to end of previous line.\n     * \n     * TODO - Implement inline groups instead?\n     */\n    if (source.type === 'text' && /^[!,;\\.]/.test(current_line_value)) {\n      if (current_line_value.length === 1) {\n        output_lines[output_lines.length - 1] = \n          output_lines.at(-1) + current_line_value;\n        return\n      } else {\n        output_lines[output_lines.length - 1] = \n          output_lines.at(-1) + current_line_value.charAt(0);\n        current_line_value = current_line_value.slice(1).trim();\n      }\n    }\n\n    const padding = step.repeat(current_indent_level);\n\n    if (is_ignored_content) {\n      /* Stop processing this line, as it's set to be ignored. */\n      output_lines.push(current_line_value);\n    } else {\n      /* Remove comment. */\n      if (strict && current_line_value.trim().startsWith(\"<!--\"))\n        return\n\n      let result = current_line_value;\n\n      if (\n        source.type === 'text' && \n        content_wrap > 0 && \n        result.length >= content_wrap\n      ) {\n        result = wordWrap(result, content_wrap, padding);\n      }\n      /* Wrap the attributes of open tags and void elements. */\n      else if (\n        tag_wrap > 0 &&\n        result.length > tag_wrap &&\n        tag_regex.test(result)\n      ) {\n        tag_regex.lastIndex = 0; // Reset stateful regex\n        attribute_regex.lastIndex = 0; // Reset stateful regex\n\n        const tag_parts = result.split(attribute_regex).filter(Boolean);\n\n        if (tag_parts.length >= 2) {\n          const attributes = result.matchAll(attribute_regex);\n          const inner_padding = padding + step;\n          let wrapped_tag = padding + tag_parts[0] + \"\\n\";\n\n          for (const a of attributes) {\n            const attribute_string = a[0].trim();\n            wrapped_tag += inner_padding + attribute_string + \"\\n\";\n          }\n\n          const tag_name_match = tag_parts[0].match(/<([A-Za-z_:-]+)/);\n          const tag_name = tag_name_match ? tag_name_match[1] : \"\";\n          const is_void = VOID_ELEMENTS.includes(tag_name);\n          const closing_part = tag_parts[1].trim();\n          const closing_padding = padding + (strict && is_void ? \" \" : \"\"); // Add space if void/strict\n\n          wrapped_tag += closing_padding + closing_part;\n\n          result = wrapped_tag; // Assign the fully wrapped string\n        } else {\n          result = padding + result;\n        }\n      } else {\n        /* Apply simple indentation (if no wrapping occurred) */\n        result = padding + result;\n      }\n\n      /* Add the processed line (or lines if wordWrap creates them) to the output */\n      output_lines.push(result);\n    }\n  });\n\n  /* Join all processed lines into the final HTML string */\n  let final_html = output_lines.join(\"\\n\");\n\n  /* Preserve wrapped attributes. */\n  if (tag_wrap > 0) final_html = protectAttributes(final_html);\n\n  /* Extra preserve wrapped content. */\n  if (content_wrap > 0 && /\\n[ ]*[^\\n]*__!i-£___£%__[^\\n]*\\n/.test(final_html))\n    final_html = finalProtectContent(final_html);\n\n  /* Remove line returns, tabs, and consecutive spaces within html elements or their content. */\n  final_html = final_html.replace(\n    /<(?<Element>.+).*>[^<]*?[^><\\/\\s][^<]*?<\\/{1}\\k<Element>|<script[^>]*>\\s+<\\/script>|<(\\w+)>\\s+<\\/(\\w+)|<(?:([\\w:\\._-]+)|([\\w:\\._-]+)[^>]*[^\\/])>\\s+<\\/([\\w:\\._-]+)>/g,\n    match => match.replace(/\\n|\\t|\\s{2,}/g, '')\n  );\n\n  /* Revert wrapped content. */\n  if (content_wrap > 0) final_html = unprotectContent(final_html);\n\n  /* Revert wrapped attributes. */\n  if (tag_wrap > 0) final_html = unprotectAttributes(final_html);\n\n  /* Remove self-closing nature of void elements. */\n  if (strict) final_html = final_html.replace(/\\s\\/>|\\/>/g, '>');\n\n  /* Trim leading and/or trailing line returns. */\n  if (final_html.startsWith(\"\\n\")) final_html = final_html.substring(1);\n  if (final_html.endsWith(\"\\n\")) final_html = final_html.substring(0, final_html.length - 1);\n\n  return final_html\n};\n\n/**\n * Format HTML with line returns and indentations.\n * \n * @param {string} html The HTML string to prettify.\n * @param {import('htmlfy').UserConfig} [config] A user configuration object.\n * @returns {string} A well-formed HTML string.\n */\nconst prettify = (html, config) => {\n  /* Return content as-is if it does not contain any HTML elements. */\n  if (!isHtml(html)) return html\n\n  const validated_config = config ? validateConfig(config) : CONFIG;\n  strict = validated_config.strict;\n\n  const ignore = validated_config.ignore.length > 0;\n  trim = validated_config.trim;\n\n  /* Extract ignored elements. */\n  if (ignore) {\n    const { html_with_markers, extracted_map } = extractIgnoredBlocks(html, validated_config);\n    html = html_with_markers;\n    ignore_map = extracted_map;\n  }\n\n  /* Preserve html text within attribute values. */\n  html = setIgnoreAttribute(html);\n\n  html = preprocess(html);\n  html = process(html, validated_config);\n\n  /* Revert html text within attribute values. */\n  html = unsetIgnoreAttribute(html);\n\n  /* Re-insert ignored elements. */\n  if (ignore) {\n    html = reinsertIgnoredBlocks(html, ignore_map);\n  }\n\n  return html\n};\n\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nexport { prettify as default };\n"],"names":["CONFIG","content_wrap","ignore","ignore_with","strict","tab_size","tag_wrap","tag_wrap_width","trim","VOID_ELEMENTS","isHtml","content","test","mergeObjects","current","updates","Error","merged","Array","isArray","structuredClone","concat","key","Object","keys","escapedIgnoreString","replace","ltPlaceholderRegex","RegExp","gtPlaceholderRegex","validateConfig","config","hasOwn","Number","isSafeInteger","Math","floor","_config$ignore","every","e","console","warn","_config$trim","dconfig","mergeConfig","entify","html","minify","match","capture","convert","line","ignore_map","preprocess","name","indexOf","substring","length","closify","leading_whitespace","trailing_whitespace","trimify","attr_name","quote","value","i","c1","c2","push","type","enqueue","process","step","repeat","placeholder_template","indents","output_lines","tag_regex","attribute_regex","forEach","source","index","current_line_value","is_ignored_content","startsWith","subtrahend","prev_line_data","prev_line_value","endsWith","current_indent_level","max","at","charAt","slice","padding","result","text","width","indent","words","split","lines","current_line","padding_string","word","test_line","join","CONTENT_IGNORE_STRING","wordWrap","lastIndex","tag_parts","filter","Boolean","attributes","matchAll","inner_padding","wrapped_tag","a","tag_name_match","tag_name","is_void","includes","closing_part","final_html","IGNORE_STRING","protectAttributes","p1","p2","p3","p4","text_to_protect","protected_text","finalProtectContent","unprotectContent","unprotectAttributes","validated_config","html_with_markers","extracted_map","current_html","extracted_blocks","Map","marker_id","tag","safe_tag_name","regex","replacements","exec","marker","set","start","end","rep","extractIgnoredBlocks","setIgnoreAttribute","fullMatch","tagName","attributesCapture","unsetIgnoreAttribute","original_block","reinsertIgnoredBlocks"],"mappings":"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"}