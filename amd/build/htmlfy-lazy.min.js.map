{"version":3,"file":"htmlfy-lazy.min.js","sources":["../src/htmlfy-lazy.js"],"sourcesContent":["\n/** @ts-ignore */\n/* eslint-disable */\n\n/**\n * @type {import('htmlfy').Config}\n */\nconst CONFIG = {\n  ignore: [],\n  ignore_with: '_!i-£___£%_',\n  strict: false,\n  tab_size: 2,\n  tag_wrap: false,\n  tag_wrap_width: 80,\n  trim: []\n};\n\n/**\n * Checks if content contains at least one HTML element.\n * \n * @param {string} content Content to evaluate.\n * @returns {boolean} A boolean.\n */\nconst isHtml = (content) => /<(?<Element>[A-Za-z]+\\b)[^>]*(?:.|\\n)*?<\\/{1}\\k<Element>>/.test(content);\n\n/**\n * Generic utility which merges two objects.\n * \n * @param {any} current Original object.\n * @param {any} updates Object to merge with original.\n * @returns {any}\n */\nconst mergeObjects = (current, updates) => {\n  if (!current || !updates)\n    throw new Error(\"Both 'current' and 'updates' must be passed-in to mergeObjects()\")\n\n  /**\n   * @type {any}\n   */\n  let merged;\n  \n  if (Array.isArray(current)) {\n    merged = structuredClone(current).concat(updates);\n  } else if (typeof current === 'object') {\n    merged = { ...current };\n    for (let key of Object.keys(updates)) {\n      if (typeof updates[key] !== 'object') {\n        merged[key] = updates[key];\n      } else {\n        /* key is an object, run mergeObjects again. */\n        merged[key] = mergeObjects(merged[key] || {}, updates[key]);\n      }\n    }\n  }\n\n  return merged\n};\n\n/**\n * Merge a user config with the default config.\n * \n * @param {import('htmlfy').Config} dconfig The default config.\n * @param {import('htmlfy').UserConfig} config The user config.\n * @returns {import('htmlfy').Config}\n */\nconst mergeConfig = (dconfig, config) => {\n  /**\n   * We need to make a deep copy of `dconfig`,\n   * otherwise we end up altering the original `CONFIG` because `dconfig` is a reference to it.\n   */\n  return mergeObjects(structuredClone(dconfig), config)\n};\n\n/**\n * Replace entities with ignore string.\n * \n * @param {string} html \n * @param {import('htmlfy').Config} config\n * @returns {string}\n */\nconst setIgnoreElement = (html, config) => {\n  const ignore = config.ignore;\n  const ignore_string = config.ignore_with;\n\n  for (let e = 0; e < ignore.length; e++) {\n    const regex = new RegExp(`<${ignore[e]}[^>]*>((.|\\n)*?)<\\/${ignore[e]}>`, \"g\");\n\n    html = html.replace(regex, (/** @type {string} */match, /** @type {any} */capture) => {\n      return match.replace(capture, (match) => {\n        return match\n          .replace(/</g, '-' + ignore_string + 'lt-')\n          .replace(/>/g, '-' + ignore_string + 'gt-')\n          .replace(/\\n/g, '-' + ignore_string + 'nl-')\n          .replace(/\\r/g, '-' + ignore_string + 'cr-')\n          .replace(/\\s/g, '-' + ignore_string + 'ws-')\n      })\n    });\n  }\n  \n  return html\n};\n\n/**\n * Trim leading and trailing whitespace characters.\n * \n * @param {string} html\n * @param {string[]} trim\n * @returns {string}\n */\nconst trimify = (html, trim) => {\n  for (let e = 0; e < trim.length; e++) {\n    /* Whitespace character must be escaped with '\\' or RegExp() won't include it. */\n    const leading_whitespace = new RegExp(`(<${trim[e]}[^>]*>)\\\\s+`, \"g\");\n    const trailing_whitespace = new RegExp(`\\\\s+(</${trim[e]}>)`, \"g\");\n\n    html = html\n      .replace(leading_whitespace, '$1')\n      .replace(trailing_whitespace, '$1');\n  }\n\n  return html\n};\n\n/**\n * Replace ignore string with entities.\n * \n * @param {string} html \n * @param {import('htmlfy').Config} config\n * @returns {string}\n */\nconst unsetIgnoreElement = (html, config) => {\n  const ignore = config.ignore;\n  const ignore_string = config.ignore_with;\n\n  for (let e = 0; e < ignore.length; e++) {\n    const regex = new RegExp(`<${ignore[e]}[^>]*>((.|\\n)*?)<\\/${ignore[e]}>`, \"g\");\n\n    html = html.replace(regex, (/** @type {string} */match, /** @type {any} */capture) => {\n      return match.replace(capture, (match) => {\n        return match\n          .replace(new RegExp('-' + ignore_string + 'lt-', \"g\"), '<')\n          .replace(new RegExp('-' + ignore_string + 'gt-', \"g\"), '>')\n          .replace(new RegExp('-' + ignore_string + 'nl-', \"g\"), '\\n')\n          .replace(new RegExp('-' + ignore_string + 'cr-', \"g\"), '\\r')\n          .replace(new RegExp('-' + ignore_string + 'ws-', \"g\"), ' ')\n      })\n    });\n  }\n  \n  return html\n};\n\n/**\n * Validate any passed-in config options and merge with CONFIG.\n * \n * @param {import('htmlfy').UserConfig} config A user config.\n * @returns {import('htmlfy').Config} A validated config.\n */\nconst validateConfig = (config) => {\n  if (typeof config !== 'object') throw new Error('Config must be an object.')\n\n  const config_empty = !(\n    Object.hasOwn(config, 'ignore') || \n    Object.hasOwn(config, 'ignore_with') || \n    Object.hasOwn(config, 'strict') || \n    Object.hasOwn(config, 'tab_size') || \n    Object.hasOwn(config, 'tag_wrap') || \n    Object.hasOwn(config, 'tag_wrap_width') || \n    Object.hasOwn(config, 'trim')\n  );\n\n  if (config_empty) return CONFIG\n\n  let tab_size = config.tab_size;\n\n  if (tab_size) {\n    if (typeof tab_size !== 'number') throw new Error(`tab_size must be a number, not ${typeof config.tab_size}.`)\n\n    const safe = Number.isSafeInteger(tab_size);\n    if (!safe) throw new Error(`Tab size ${tab_size} is not safe. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger for more info.`)\n\n    /** \n     * Round down, just in case a safe floating point,\n     * like 4.0, was passed.\n     */\n    tab_size = Math.floor(tab_size);\n    if (tab_size < 1 || tab_size > 16) throw new Error('Tab size out of range. Expecting 1 to 16.')\n  \n    config.tab_size = tab_size;\n  }\n\n  if (Object.hasOwn(config, 'ignore') && (!Array.isArray(config.ignore) || !config.ignore?.every((e) => typeof e === 'string')))\n    throw new Error('Ignore config must be an array of strings.')\n\n  if (Object.hasOwn(config, 'ignore_with') && typeof config.ignore_with !== 'string')\n    throw new Error(`Ignore_with config must be a string, not ${typeof config.ignore_with}.`)\n\n  if (Object.hasOwn(config, 'strict') && typeof config.strict !== 'boolean')\n    throw new Error(`Strict config must be a boolean, not ${typeof config.strict}.`)\n\n  if (Object.hasOwn(config, 'tag_wrap') && typeof config.tag_wrap !== 'boolean')\n    throw new Error(`tag_wrap config must be a boolean, not ${typeof config.tag_wrap}.`)\n\n  if (Object.hasOwn(config, 'tag_wrap_width') && typeof config.tag_wrap_width !== 'number')\n    throw new Error(`tag_wrap_width config must be a number, not ${typeof config.tag_wrap_width}.`)\n\n  if (Object.hasOwn(config, 'trim') && (!Array.isArray(config.trim) || !config.trim?.every((e) => typeof e === 'string')))\n    throw new Error('Trim config must be an array of strings.')\n\n  return mergeConfig(CONFIG, config)\n\n};\n\nconst void_elements = [\n  'area', 'base', 'br', 'col', 'embed', 'hr', \n  'img', 'input', 'link', 'meta',\n  'param', 'source', 'track', 'wbr'\n];\n\n/**\n * Ensure void elements are \"self-closing\".\n * \n * @param {string} html The HTML string to evaluate.\n * @param {boolean} check_html Check to see if the content contains any HTML, before processing.\n * @returns {string}\n * @example <br> => <br />\n */\nconst closify = (html, check_html = true) => {\n  if (check_html && !isHtml(html)) return html\n  \n  return html.replace(/<([a-zA-Z\\-0-9]+)[^>]*>/g, (match, name) => {\n    if (void_elements.indexOf(name) > -1)\n      return (`${match.substring(0, match.length - 1)} />`).replace(/\\/\\s\\//g, '/')\n\n    return match.replace(/[\\s]?\\/>/g, `></${name}>`)\n  })\n};\n\n/**\n * Enforce entity characters for textarea content.\n * To also minifiy, pass `minify` as `true`.\n * \n * @param {string} html The HTML string to evaluate.\n * @param {boolean} [minify] Fully minifies the content of textarea elements. \n * Defaults to `false`. We recommend a value of `true` if you're running `entify()` \n * as a standalone function.\n * @returns {string}\n * @example <textarea>3 > 2</textarea> => <textarea>3 &gt; 2</textarea>\n */\nconst entify = (html, minify = false) => {\n  /** \n   * Use entities inside textarea content.\n   */\n  html = html.replace(/<textarea[^>]*>((.|\\n)*?)<\\/textarea>/g, (match, capture) => {\n    return match.replace(capture, (match) => {\n      return match\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&apos;')\n        .replace(/\\n/g, '&#10;')\n        .replace(/\\r/g, '&#13;')\n        .replace(/\\s/g, '&nbsp;')\n    })\n  });\n\n  /* Typical minification, but only for textareas. */\n  if (minify) {\n    html = html.replace(/<textarea[^>]*>((.|\\n)*?)<\\/textarea>/g, (match, capture) => {\n      /* Replace things inside the textarea content. */\n      match = match.replace(capture, (match) => {\n        return match\n          .replace(/\\n|\\t/g, '')\n          .replace(/[a-z]+=\"\\s*\"/ig, '')\n          .replace(/>\\s+</g, '><')\n          .replace(/\\s+/g, ' ')\n      });\n\n      /* Replace things in the entire element */\n      match = match\n        .replace(/\\s+/g, ' ')\n        .replace(/\\s>/g, '>')\n        .replace(/>\\s/g, '>')\n        .replace(/\\s</g, '<')\n        .replace(/class=[\"']\\s/g, (match) => match.replace(/\\s/g, ''))\n        .replace(/(class=.*)\\s([\"'])/g, '$1'+'$2');\n      return match\n    });\n  }\n\n  return html\n};\n\n/**\n * Creates a single-line HTML string\n * by removing line returns, tabs, and relevant spaces.\n * \n * @param {string} html The HTML string to minify.\n * @param {boolean} check_html Check to see if the content contains any HTML, before processing.\n * @returns {string} A minified HTML string.\n */\nconst minify = (html, check_html = true) => {\n  if (check_html && !isHtml(html)) return html\n\n  /**\n   * Ensure textarea content is specially minified and protected\n   * before general minification.\n   */\n  html = entify(html);\n\n  /* All other minification. */\n  return html\n    .replace(/\\n|\\t/g, '')\n    .replace(/[a-z]+=\"\\s*\"/ig, '')\n    .replace(/>\\s+</g, '><')\n    .replace(/\\s+/g, ' ')\n    .replace(/\\s>/g, '>')\n    .replace(/<\\s\\//g, '</')\n    .replace(/>\\s/g, '>')\n    .replace(/\\s</g, '<')\n    .replace(/class=[\"']\\s/g, (match) => match.replace(/\\s/g, ''))\n    .replace(/(class=.*)\\s([\"'])/g, '$1'+'$2')\n};\n\n/**\n * @type {boolean}\n */\nlet strict;\n\n/**\n * @type {string[]}\n */\nlet trim;\n\n/**\n * @type {{ line: string[] }}\n */\nconst convert = {\n  line: []\n};\n\n/**\n * Isolate tags, content, and comments.\n * \n * @param {string} html The HTML string to evaluate.\n * @returns {string}\n * @example <div>Hello World!</div> => \n *  [#-# : 0 : <div> : #-#]\n *  Hello World!\n *  [#-# : 1 : </div> : #-#]\n */\nconst enqueue = (html) => {\n  convert.line = [];\n  let i = -1;\n\n  html = html.replace(/<[^>]*>/g, (match) => {\n    convert.line.push(match);\n    i++;\n\n    return `\\n[#-# : ${i} : ${match} : #-#]\\n`\n  });\n\n  return html\n};\n\n/**\n * Preprocess the HTML.\n * \n * @param {string} html The HTML string to preprocess.\n * @returns {string}\n */\nconst preprocess = (html) => {\n  html = closify(html, false);\n\n  if (trim.length > 0) html = trimify(html, trim);\n\n  html = minify(html, false);\n  html = enqueue(html);\n\n  return html\n};\n\n/**\n * \n * @param {string} html The HTML string to process.\n * @param {import('htmlfy').Config} config \n * @returns {string}\n */\nconst process = (html, config) => {\n  const step = config.tab_size;\n  const wrap = config.tag_wrap;\n  const wrap_width = config.tag_wrap_width;\n\n  /* Track current number of indentations needed. */\n  let indents = '';\n\n  /* Process lines and indent. */\n  convert.line.forEach((source, index) => {\n    html = html\n      .replace(/\\n+/g, '\\n') /* Replace consecutive line returns with singles. */\n      .replace(`[#-# : ${index} : ${source} : #-#]`, (match) => {\n        let subtrahend = 0;\n        const prevLine = `[#-# : ${index - 1} : ${convert.line[index - 1]} : #-#]`;\n\n        /**\n         * Arbitratry character, to keep track of the string's length.\n         */\n        indents += '0';\n        \n        if (index === 0) subtrahend++;\n\n        /* We're processing a closing tag. */\n        if (match.indexOf(`#-# : ${index} : </`) > -1) subtrahend++;\n\n        /* prevLine is a doctype declaration. */\n        if (prevLine.indexOf('<!doctype') > -1) subtrahend++;\n\n        /* prevLine is a comment. */\n        if (prevLine.indexOf('<!--') > -1) subtrahend++;\n\n        /* prevLine is a self-closing tag. */\n        if (prevLine.indexOf('/> : #-#') > -1) subtrahend++;\n\n        /* prevLine is a closing tag. */\n        if (prevLine.indexOf(`#-# : ${index - 1} : </`) > -1) subtrahend++;\n\n        /* Determine offset for line indentation. */\n        const offset = indents.length - subtrahend;\n\n        /* Adjust for the next round. */\n        indents = indents.substring(0, offset);\n\n        /* Remove comment. */\n        if (strict && match.indexOf('<!--') > -1) return ''\n\n        /* Remove the prefix and suffix, leaving the content. */\n        const result = match\n          .replace(`[#-# : ${index} : `, '')\n          .replace(' : #-#]', '');\n        \n        const tag_regex = /<[A-Za-z]+\\b[^>]*(?:.|\\n)*?\\/?>/g; /* Is opening tag or void element. */\n\n        /* Wrap the attributes of open tags and void elements. */\n        if (wrap && tag_regex.test(source) && source.length > wrap_width) {\n          const attribute_regex = /\\s{1}[A-Za-z-]+(?:=\".*?\")?/g; /* Matches all tag/element attributes. */\n          const tag_parts = source.split(attribute_regex).filter(Boolean);\n          const attributes = source.matchAll(attribute_regex);\n          const padding = step * offset;\n          const inner_padding = padding + step;\n\n          let wrapped = tag_parts[0].padStart(tag_parts[0].length + padding) + `\\n`;\n          for (const a of attributes) {\n            /* Must declare separately so we can pad this string before adding it to `wrapped`. */\n            const a_string = a[0].trim().padStart(a[0].trim().length + inner_padding) + `\\n`;\n            wrapped += a_string;\n          }\n          const e_string = tag_parts[1].padStart(tag_parts[1].trim().length + padding + (strict ? 1 : 0));\n          wrapped += e_string;\n\n          return wrapped\n        } else {\n          /* Pad the string with spaces and return. */\n          return result.padStart(result.length + (step * offset))\n        }\n      });\n  });\n\n  /* Remove line returns, tabs, and consecutive spaces within html elements or their content. */\n  html = html.replace(\n    />[^<]*?[^><\\/\\s][^<]*?<\\/|>\\s+[^><\\s]|<script[^>]*>\\s+<\\/script>|<(\\w+)>\\s+<\\/(\\w+)|<([\\w\\-]+)[^>]*[^\\/]>\\s+<\\/([\\w\\-]+)>/g,\n    match => match.replace(/\\n|\\t|\\s{2,}/g, '')\n  );\n\n  /* Remove self-closing nature of void elements. */\n  if (strict) html = html.replace(/\\s\\/>|\\/>/g, '>');\n\n  const lead_newline_check = html.substring(0, 1);\n  const tail_newline_check = html.substring(html.length - 1);\n\n  /**\n   * Remove single leading and trailing new line, if they exist.\n   * These will be `false` if the \"html\" being processed is only plain text. \n   */\n  if (lead_newline_check === '\\n') html = html.substring(1, html.length);\n  if (tail_newline_check === '\\n') html = html.substring(0, html.length - 1);\n\n  return html\n};\n\n/**\n * Format HTML with line returns and indentations.\n * \n * @param {string} html The HTML string to prettify.\n * @param {import('htmlfy').UserConfig} [config] A user configuration object.\n * @returns {string} A well-formed HTML string.\n */\nconst prettify = (html, config) => {\n  /* Return content as-is if it does not contain any HTML elements. */\n  if (!isHtml(html)) return html\n\n  const validated_config = config ? validateConfig(config) : CONFIG;\n  strict = validated_config.strict;\n\n  const ignore = validated_config.ignore.length > 0;\n  trim = validated_config.trim;\n\n  /* Preserve ignored elements. */\n  if (ignore) html = setIgnoreElement(html, validated_config);\n\n  html = preprocess(html);\n  html = process(html, validated_config);\n\n  /* Revert ignored elements. */\n  if (ignore) html = unsetIgnoreElement(html, validated_config);\n\n  return html\n};\n\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nexport { prettify as default };\n"],"names":["CONFIG","ignore","ignore_with","strict","tab_size","tag_wrap","tag_wrap_width","trim","isHtml","content","test","mergeObjects","current","updates","Error","merged","Array","isArray","structuredClone","concat","key","Object","keys","validateConfig","config","hasOwn","Number","isSafeInteger","Math","floor","_config$ignore","every","e","_config$trim","dconfig","mergeConfig","void_elements","entify","html","minify","replace","match","capture","convert","line","preprocess","name","indexOf","substring","length","closify","leading_whitespace","RegExp","trailing_whitespace","trimify","i","push","enqueue","validated_config","ignore_string","regex","setIgnoreElement","step","wrap","wrap_width","indents","forEach","source","index","subtrahend","prevLine","offset","result","attribute_regex","tag_parts","split","filter","Boolean","attributes","matchAll","padding","inner_padding","wrapped","padStart","a","lead_newline_check","tail_newline_check","process","unsetIgnoreElement"],"mappings":"wJAOMA,OAAS,CACbC,OAAQ,GACRC,YAAa,cACbC,QAAQ,EACRC,SAAU,EACVC,UAAU,EACVC,eAAgB,GAChBC,KAAM,IASFC,OAAUC,SAAY,4DAA4DC,KAAKD,SASvFE,aAAe,CAACC,QAASC,eACxBD,UAAYC,QACf,MAAM,IAAIC,MAAM,wEAKdC,UAEAC,MAAMC,QAAQL,SAChBG,OAASG,gBAAgBN,SAASO,OAAON,cACpC,GAAuB,iBAAZD,QAAsB,CACtCG,OAAS,IAAKH,aACT,IAAIQ,OAAOC,OAAOC,KAAKT,SACE,iBAAjBA,QAAQO,KACjBL,OAAOK,KAAOP,QAAQO,KAGtBL,OAAOK,KAAOT,aAAaI,OAAOK,MAAQ,GAAIP,QAAQO,aAKrDL,QAuGHQ,eAAkBC,4CACA,iBAAXA,OAAqB,MAAM,IAAIV,MAAM,kCAG9CO,OAAOI,OAAOD,OAAQ,WACtBH,OAAOI,OAAOD,OAAQ,gBACtBH,OAAOI,OAAOD,OAAQ,WACtBH,OAAOI,OAAOD,OAAQ,aACtBH,OAAOI,OAAOD,OAAQ,aACtBH,OAAOI,OAAOD,OAAQ,mBACtBH,OAAOI,OAAOD,OAAQ,SAGN,OAAOxB,WAErBI,SAAWoB,OAAOpB,YAElBA,SAAU,IACY,iBAAbA,SAAuB,MAAM,IAAIU,MAAO,yCAAwCU,OAAOpB,iBAErFsB,OAAOC,cAAcvB,UACvB,MAAM,IAAIU,MAAO,YAAWV,qJAMvCA,SAAWwB,KAAKC,MAAMzB,UAClBA,SAAW,GAAKA,SAAW,GAAI,MAAM,IAAIU,MAAM,6CAEnDU,OAAOpB,SAAWA,YAGhBiB,OAAOI,OAAOD,OAAQ,aAAeR,MAAMC,QAAQO,OAAOvB,gCAAYuB,OAAOvB,mCAAP6B,eAAeC,OAAOC,GAAmB,iBAANA,KAC3G,MAAM,IAAIlB,MAAM,iDAEdO,OAAOI,OAAOD,OAAQ,gBAAgD,iBAAvBA,OAAOtB,YACxD,MAAM,IAAIY,MAAO,mDAAkDU,OAAOtB,mBAExEmB,OAAOI,OAAOD,OAAQ,WAAsC,kBAAlBA,OAAOrB,OACnD,MAAM,IAAIW,MAAO,+CAA8CU,OAAOrB,cAEpEkB,OAAOI,OAAOD,OAAQ,aAA0C,kBAApBA,OAAOnB,SACrD,MAAM,IAAIS,MAAO,iDAAgDU,OAAOnB,gBAEtEgB,OAAOI,OAAOD,OAAQ,mBAAsD,iBAA1BA,OAAOlB,eAC3D,MAAM,IAAIQ,MAAO,sDAAqDU,OAAOlB,sBAE3Ee,OAAOI,OAAOD,OAAQ,WAAaR,MAAMC,QAAQO,OAAOjB,4BAAUiB,OAAOjB,+BAAP0B,aAAaF,OAAOC,GAAmB,iBAANA,KACrG,MAAM,IAAIlB,MAAM,kDA9IA,EAACoB,QAASV,SAKrBb,aAAaO,gBAAgBgB,SAAUV,QA2IvCW,CAAYnC,OAAQwB,SAIvBY,cAAgB,CACpB,OAAQ,OAAQ,KAAM,MAAO,QAAS,KACtC,MAAO,QAAS,OAAQ,OACxB,QAAS,SAAU,QAAS,OAiCxBC,OAAS,SAACC,UAAMC,sEAIpBD,KAAOA,KAAKE,QAAQ,0CAA0C,CAACC,MAAOC,UAC7DD,MAAMD,QAAQE,SAAUD,OACtBA,MACJD,QAAQ,KAAM,QACdA,QAAQ,KAAM,QACdA,QAAQ,KAAM,UACdA,QAAQ,KAAM,UACdA,QAAQ,MAAO,SACfA,QAAQ,MAAO,SACfA,QAAQ,MAAO,cAKlBD,SACFD,KAAOA,KAAKE,QAAQ,0CAA0C,CAACC,MAAOC,UAWpED,OATAA,MAAQA,MAAMD,QAAQE,SAAUD,OACvBA,MACJD,QAAQ,SAAU,IAClBA,QAAQ,iBAAkB,IAC1BA,QAAQ,SAAU,MAClBA,QAAQ,OAAQ,QAKlBA,QAAQ,OAAQ,KAChBA,QAAQ,OAAQ,KAChBA,QAAQ,OAAQ,KAChBA,QAAQ,OAAQ,KAChBA,QAAQ,iBAAkBC,OAAUA,MAAMD,QAAQ,MAAO,MACzDA,QAAQ,sBAAuB,WAK/BF,UAqCLnC,OAKAI,WAKEoC,QAAU,CACdC,KAAM,IAiCFC,WAAcP,OAClBA,KAjJc,SAACA,uEACI9B,OAAO8B,MAEnBA,KAAKE,QAAQ,4BAA4B,CAACC,MAAOK,OAClDV,cAAcW,QAAQD,OAAS,EACxB,GAAEL,MAAMO,UAAU,EAAGP,MAAMQ,OAAS,QAAST,QAAQ,UAAW,KAEpEC,MAAMD,QAAQ,YAAc,MAAKM,WANFR,KAgJjCY,CAAQZ,MAAM,GAEjB/B,KAAK0C,OAAS,IAAGX,KAzQP,EAACA,KAAM/B,YAChB,IAAIyB,EAAI,EAAGA,EAAIzB,KAAK0C,OAAQjB,IAAK,OAE9BmB,mBAAqB,IAAIC,OAAQ,KAAI7C,KAAKyB,gBAAiB,KAC3DqB,oBAAsB,IAAID,OAAQ,UAAS7C,KAAKyB,OAAQ,KAE9DM,KAAOA,KACJE,QAAQW,mBAAoB,MAC5BX,QAAQa,oBAAqB,aAG3Bf,MA8PqBgB,CAAQhB,KAAM/B,OAE1C+B,KA3Ea,SAACA,uEACK9B,OAAO8B,OAM1BA,KAAOD,OAAOC,OAIXE,QAAQ,SAAU,IAClBA,QAAQ,iBAAkB,IAC1BA,QAAQ,SAAU,MAClBA,QAAQ,OAAQ,KAChBA,QAAQ,OAAQ,KAChBA,QAAQ,SAAU,MAClBA,QAAQ,OAAQ,KAChBA,QAAQ,OAAQ,KAChBA,QAAQ,iBAAkBC,OAAUA,MAAMD,QAAQ,MAAO,MACzDA,QAAQ,sBAAuB,QAnBMF,KA0EjCC,CAAOD,MAAM,GACpBA,KA1BeA,CAAAA,OACfK,QAAQC,KAAO,OACXW,GAAK,SAEFjB,KAAKE,QAAQ,YAAaC,QAC/BE,QAAQC,KAAKY,KAAKf,OAClBc,IAEQ,YAAWA,OAAOd,qBAkBrBgB,CAAQnB,+BAuHA,CAACA,KAAMd,cAEjBhB,OAAO8B,MAAO,OAAOA,WAEpBoB,iBAAmBlC,OAASD,eAAeC,QAAUxB,OAC3DG,OAASuD,iBAAiBvD,aAEpBF,OAASyD,iBAAiBzD,OAAOgD,OAAS,SAChD1C,KAAOmD,iBAAiBnD,KAGpBN,SAAQqC,KA3aW,EAACA,KAAMd,gBACxBvB,OAASuB,OAAOvB,OAChB0D,cAAgBnC,OAAOtB,gBAExB,IAAI8B,EAAI,EAAGA,EAAI/B,OAAOgD,OAAQjB,IAAK,OAChC4B,MAAQ,IAAIR,OAAQ,IAAGnD,OAAO+B,uBAAwB/B,OAAO+B,MAAO,KAE1EM,KAAOA,KAAKE,QAAQoB,OAAO,CAAsBnB,MAAyBC,UACjED,MAAMD,QAAQE,SAAUD,OACtBA,MACJD,QAAQ,KAAM,IAAMmB,cAAgB,OACpCnB,QAAQ,KAAM,IAAMmB,cAAgB,OACpCnB,QAAQ,MAAO,IAAMmB,cAAgB,OACrCnB,QAAQ,MAAO,IAAMmB,cAAgB,OACrCnB,QAAQ,MAAO,IAAMmB,cAAgB,kBAKvCrB,MAwZYuB,CAAiBvB,KAAMoB,mBAG1CpB,KA1Hc,EAACA,KAAMd,gBACfsC,KAAOtC,OAAOpB,SACd2D,KAAOvC,OAAOnB,SACd2D,WAAaxC,OAAOlB,mBAGtB2D,QAAU,GAGdtB,QAAQC,KAAKsB,SAAQ,CAACC,OAAQC,SAC5B9B,KAAOA,KACJE,QAAQ,OAAQ,MAChBA,QAAS,UAAS4B,WAAWD,iBAAkB1B,YAC1C4B,WAAa,QACXC,SAAY,UAASF,MAAQ,OAAOzB,QAAQC,KAAKwB,MAAQ,YAK/DH,SAAW,IAEG,IAAVG,OAAaC,aAGb5B,MAAMM,QAAS,SAAQqB,eAAiB,GAAGC,aAG3CC,SAASvB,QAAQ,cAAgB,GAAGsB,aAGpCC,SAASvB,QAAQ,YAAW,GAAGsB,aAG/BC,SAASvB,QAAQ,aAAe,GAAGsB,aAGnCC,SAASvB,QAAS,SAAQqB,MAAQ,WAAa,GAAGC,mBAGhDE,OAASN,QAAQhB,OAASoB,cAGhCJ,QAAUA,QAAQjB,UAAU,EAAGuB,QAG3BpE,QAAUsC,MAAMM,QAAQ,YAAW,EAAG,MAAO,SAG3CyB,OAAS/B,MACZD,QAAS,UAAS4B,WAAY,IAC9B5B,QAAQ,UAAW,OAKlBuB,MAHc,mCAGIrD,KAAKyD,SAAWA,OAAOlB,OAASe,WAAY,OAC1DS,gBAAkB,8BAClBC,UAAYP,OAAOQ,MAAMF,iBAAiBG,OAAOC,SACjDC,WAAaX,OAAOY,SAASN,iBAC7BO,QAAUlB,KAAOS,OACjBU,cAAgBD,QAAUlB,SAE5BoB,QAAUR,UAAU,GAAGS,SAAST,UAAU,GAAGzB,OAAS+B,SAAY,SACjE,MAAMI,KAAKN,WAGdI,SADiBE,EAAE,GAAG7E,OAAO4E,SAASC,EAAE,GAAG7E,OAAO0C,OAASgC,eAAkB,YAI/EC,SADiBR,UAAU,GAAGS,SAAST,UAAU,GAAGnE,OAAO0C,OAAS+B,SAAW7E,OAAS,EAAI,IAGrF+E,eAGAV,OAAOW,SAASX,OAAOvB,OAAUa,KAAOS,cAMvDjC,KAAOA,KAAKE,QACV,8HACAC,OAASA,MAAMD,QAAQ,gBAAiB,MAItCrC,SAAQmC,KAAOA,KAAKE,QAAQ,aAAc,YAExC6C,mBAAqB/C,KAAKU,UAAU,EAAG,GACvCsC,mBAAqBhD,KAAKU,UAAUV,KAAKW,OAAS,SAM7B,OAAvBoC,qBAA6B/C,KAAOA,KAAKU,UAAU,EAAGV,KAAKW,SACpC,OAAvBqC,qBAA6BhD,KAAOA,KAAKU,UAAU,EAAGV,KAAKW,OAAS,IAEjEX,MAwBAiD,CADPjD,KAAOO,WAAWP,MACGoB,kBAGjBzD,SAAQqC,KA/Xa,EAACA,KAAMd,gBAC1BvB,OAASuB,OAAOvB,OAChB0D,cAAgBnC,OAAOtB,gBAExB,IAAI8B,EAAI,EAAGA,EAAI/B,OAAOgD,OAAQjB,IAAK,OAChC4B,MAAQ,IAAIR,OAAQ,IAAGnD,OAAO+B,uBAAwB/B,OAAO+B,MAAO,KAE1EM,KAAOA,KAAKE,QAAQoB,OAAO,CAAsBnB,MAAyBC,UACjED,MAAMD,QAAQE,SAAUD,OACtBA,MACJD,QAAQ,IAAIY,OAAO,IAAMO,cAAgB,MAAO,KAAM,KACtDnB,QAAQ,IAAIY,OAAO,IAAMO,cAAgB,MAAO,KAAM,KACtDnB,QAAQ,IAAIY,OAAO,IAAMO,cAAgB,MAAO,KAAM,MACtDnB,QAAQ,IAAIY,OAAO,IAAMO,cAAgB,MAAO,KAAM,MACtDnB,QAAQ,IAAIY,OAAO,IAAMO,cAAgB,MAAO,KAAM,gBAKxDrB,MA4WYkD,CAAmBlD,KAAMoB,mBAErCpB"}