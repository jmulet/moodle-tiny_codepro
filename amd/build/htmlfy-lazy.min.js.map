{"version":3,"file":"htmlfy-lazy.min.js","sources":["../src/htmlfy-lazy.js"],"sourcesContent":["\n/** @ts-ignore */\n/* eslint-disable */\n\n/**\n * @type {import('types').DefaultConfig}\n */\nconst CONFIG = {\n  ignore: [],\n  strict: false,\n  tab_size: 2,\n  trim: []\n};\n\n/**\n * Checks if content contains at least one HTML element.\n * \n * @param {string} content Content to evaluate.\n * @returns {boolean} A boolean.\n */\nconst isHtml = (content) => {\n  const regex = /<(?<Element>[A-Za-z]+\\b)[^>]*(?:.|\\n)*?<\\/{1}\\k<Element>>/;\n  return regex.test(content)\n};\n\n/**\n * Generic utility which merges two objects.\n * \n * @param {any} current Original object.\n * @param {any} updates Object to merge with original.\n * @returns {any}\n */\nconst mergeObjects = (current, updates) => {\n  if (!current || !updates)\n    throw new Error(\"Both 'current' and 'updates' must be passed-in to merge()\")\n\n  /**\n   * @type {any}\n   */\n  let merged;\n  \n  if (Array.isArray(current)) {\n    merged = structuredClone(current).concat(updates);\n  } else if (typeof current === 'object') {\n    merged = { ...current };\n    for (let key of Object.keys(updates)) {\n      if (typeof updates[key] !== 'object') {\n        merged[key] = updates[key];\n      } else {\n        /* key is an object, run mergeObjects again. */\n        merged[key] = mergeObjects(merged[key] || {}, updates[key]);\n      }\n    }\n  }\n\n  return merged\n};\n\n/**\n * Merge a user config with the default config.\n * \n * @param {import('types').DefaultConfig} dconfig The default config.\n * @param {import('htmlfy').UserConfig} config The user config.\n * @returns {import('htmlfy').Config}\n */\nconst mergeConfig = (dconfig, config) => {\n  /**\n   * We need to make a deep copy of `dconfig`,\n   * otherwise we end up altering the original `CONFIG` because `dconfig` is a reference to it.\n   */\n  return mergeObjects(structuredClone(dconfig), config)\n};\n\n/**\n * Ignores elements by protecting or unprotecting their entities.\n * \n * @param {string} html \n * @param {string[]} ignore\n * @param {string} [mode]\n * @returns {string}\n */\nconst ignoreElement = (html, ignore, mode = 'protect') => {\n  for (let e = 0; e < ignore.length; e++) {\n    const regex = new RegExp(`<${ignore[e]}[^>]*>((.|\\n)*?)<\\/${ignore[e]}>`, \"g\");\n    html = html.replace(regex, mode === 'protect' ? protectElement : unprotectElement);\n  }\n\n  return html\n};\n\n/**\n * Protect an element by inserting entities.\n * \n * @param {string} match \n * @param {any} capture \n * @returns \n */\nconst protectElement = (match, capture) => {\n  return match.replace(capture, (match) => {\n    return match\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\\n/g, '&#10;')\n      .replace(/\\r/g, '&#13;')\n      .replace(/\\s/g, '&nbsp;')\n  })\n};\n\n/**\n * Trim leading and trailing whitespace characters.\n * \n * @param {string} html\n * @param {string[]} trim\n * @returns {string}\n */\nconst trimify = (html, trim) => {\n  for (let e = 0; e < trim.length; e++) {\n    /* Whitespace character must be escaped with '\\' or RegExp() won't include it. */\n    const leading_whitespace = new RegExp(`(<${trim[e]}[^>]*>)\\\\s+`, \"g\");\n    const trailing_whitespace = new RegExp(`\\\\s+(</${trim[e]}>)`, \"g\");\n\n    html = html\n      .replace(leading_whitespace, '$1')\n      .replace(trailing_whitespace, '$1');\n  }\n\n  return html\n};\n\n/**\n * Unprotect an element by removing entities.\n * \n * @param {string} match \n * @param {any} capture \n * @returns \n */\nconst unprotectElement = (match, capture) => {\n  return match.replace(capture, (match) => {\n    return match\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>')\n      .replace(/&#10;/g, '\\n')\n      .replace(/&#13;/g, '\\r')\n      .replace(/&nbsp;/g, ' ')\n  })\n};\n\n/**\n * Validate any passed-in config options and merge with CONFIG.\n * \n * @param {import('htmlfy').UserConfig} config A user config.\n * @returns {import('htmlfy').Config} A validated config.\n */\nconst validateConfig = (config) => {\n  if (typeof config !== 'object') throw new Error('Config must be an object.')\n\n  const config_empty = !(\n    Object.hasOwn(config, 'tab_size') || \n    Object.hasOwn(config, 'strict') || \n    Object.hasOwn(config, 'ignore') || \n    Object.hasOwn(config, 'trim'));\n  if (config_empty) return CONFIG\n\n  let tab_size = config.tab_size;\n\n  if (tab_size) {\n    if (typeof tab_size !== 'number') throw new Error('Tab size must be a number.')\n    const safe = Number.isSafeInteger(tab_size);\n    if (!safe) throw new Error(`Tab size ${tab_size} is not safe. See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger for more info.`)\n\n    /** \n     * Round down, just in case a safe floating point,\n     * like 4.0, was passed.\n     */\n    tab_size = Math.floor(tab_size);\n    if (tab_size < 1 || tab_size > 16) throw new Error('Tab size out of range. Expecting 1 to 16.')\n  \n    config.tab_size = tab_size;\n  }\n\n  if (Object.hasOwn(config, 'strict') && typeof config.strict !== 'boolean')\n    throw new Error('Strict config must be a boolean.')\n  if (Object.hasOwn(config, 'ignore') && (!Array.isArray(config.ignore) || !config.ignore?.every((e) => typeof e === 'string')))\n    throw new Error('Ignore config must be an array of strings.')\n  if (Object.hasOwn(config, 'trim') && (!Array.isArray(config.trim) || !config.trim?.every((e) => typeof e === 'string')))\n    throw new Error('Trim config must be an array of strings.')\n\n  return mergeConfig(CONFIG, config)\n\n};\n\nconst void_elements = [\n  'area', 'base', 'br', 'col', 'embed', 'hr', \n  'img', 'input', 'link', 'meta',\n  'param', 'source', 'track', 'wbr'\n];\n\n/**\n * Ensure void elements are \"self-closing\".\n * \n * @param {string} html The HTML string to evaluate.\n * @param {boolean} html_check Check to see if the content contains any HTML, before processing.\n * @returns {string}\n * @example <br> => <br />\n */\nconst closify = (html, html_check = true) => {\n  if (html_check)\n    if (!isHtml(html)) return html\n  \n  return html.replace(/<([a-zA-Z\\-0-9]+)[^>]*>/g, (match, name) => {\n    if (void_elements.indexOf(name) > -1) {\n      return (`${match.substring(0, match.length - 1)} />`).replace(/\\/\\s\\//g, '/')\n    }\n\n    return match.replace(/[\\s]?\\/>/g, `></${name}>`)\n  })\n};\n\n/**\n * Enforce entity characters for textarea content.\n * To also minifiy, pass `minify` as `true`.\n * \n * @param {string} html The HTML string to evaluate.\n * @param {boolean} [minify] Fully minifies the content of textarea elements. \n * Defaults to `false`. We recommend a value of `true` if you're running `entify()` \n * as a standalone function.\n * @returns {string}\n * @example <textarea>3 > 2</textarea> => <textarea>3 &gt; 2</textarea>\n */\nconst entify = (html, minify = false) => {\n  /** \n   * Use entities inside textarea content.\n   */\n  html = html.replace(/<textarea[^>]*>((.|\\n)*?)<\\/textarea>/g, (match, capture) => {\n    return match.replace(capture, (match) => {\n      return match\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&apos;')\n        .replace(/\\n/g, '&#10;')\n        .replace(/\\r/g, '&#13;')\n        .replace(/\\s/g, '&nbsp;')\n    })\n  });\n\n  /* Typical minification, but only for textareas. */\n  if (minify) {\n    html = html.replace(/<textarea[^>]*>((.|\\n)*?)<\\/textarea>/g, (match, capture) => {\n      /* Replace things inside the textarea content. */\n      match = match.replace(capture, (match) => {\n        return match\n          .replace(/\\n|\\t/g, '')\n          .replace(/[a-z]+=\"\\s*\"/ig, '')\n          .replace(/>\\s+</g, '><')\n          .replace(/\\s+/g, ' ')\n      });\n\n      /* Replace things in the entire element */\n      match = match\n        .replace(/\\s+/g, ' ')\n        .replace(/\\s>/g, '>')\n        .replace(/>\\s/g, '>')\n        .replace(/\\s</g, '<')\n        .replace(/class=[\"']\\s/g, (match) => match.replace(/\\s/g, ''))\n        .replace(/(class=.*)\\s([\"'])/g, '$1'+'$2');\n      return match\n    });\n  }\n\n  return html\n};\n\n/**\n * Creates a single-line HTML string\n * by removing line returns, tabs, and relevant spaces.\n * \n * @param {string} html The HTML string to minify.\n * @param {boolean} html_check Check to see if the content contains any HTML, before processing.\n * @returns {string} A minified HTML string.\n */\nconst minify = (html, html_check = true) => {\n  if (html_check)\n    if (!isHtml(html)) return html\n\n  /**\n   * Ensure textarea content is specially minified and protected\n   * before general minification.\n   */\n  html = entify(html);\n\n  /* All other minification. */\n  return html\n    .replace(/\\n|\\t/g, '')\n    .replace(/[a-z]+=\"\\s*\"/ig, '')\n    .replace(/>\\s+</g, '><')\n    .replace(/\\s+/g, ' ')\n    .replace(/\\s>/g, '>')\n    .replace(/<\\s\\//g, '</')\n    .replace(/>\\s/g, '>')\n    .replace(/\\s</g, '<')\n    .replace(/class=[\"']\\s/g, (match) => match.replace(/\\s/g, ''))\n    .replace(/(class=.*)\\s([\"'])/g, '$1'+'$2')\n};\n\n/**\n * @type {boolean}\n */\nlet strict;\n\n/**\n * @type {string[]}\n */\nlet trim;\n\n/**\n * @type {{ line: string[] }}\n */\nconst convert = {\n  line: []\n};\n\n/**\n * Isolate tags, content, and comments.\n * \n * @param {string} html The HTML string to evaluate.\n * @returns {string}\n * @example <div>Hello World!</div> => \n *  [#-# : 0 : <div> : #-#]\n *  Hello World!\n *  [#-# : 1 : </div> : #-#]\n */\nconst enqueue = (html) => {\n  convert.line = [];\n  let i = -1;\n\n  html = html.replace(/<[^>]*>/g, (match) => {\n    convert.line.push(match);\n    i++;\n\n    return `\\n[#-# : ${i} : ${match} : #-#]\\n`\n  });\n\n  return html\n};\n\n/**\n * Preprocess the HTML.\n * \n * @param {string} html The HTML string to preprocess.\n * @returns {string}\n */\nconst preprocess = (html) => {\n  html = closify(html, false);\n\n  if (trim.length > 0)\n    html = trimify(html, trim);\n\n  html = minify(html, false);\n  html = enqueue(html);\n\n  return html\n};\n\n/**\n * \n * @param {string} html The HTML string to process.\n * @param {number} step \n * @returns {string}\n */\nconst process = (html, step) => {\n  /* Track current number of indentations needed. */\n  let indents = '';\n\n  /* Process lines and indent. */\n  convert.line.forEach((source, index) => {\n    html = html\n      .replace(/\\n+/g, '\\n') /* Replace consecutive line returns with singles. */\n      .replace(`[#-# : ${index} : ${source} : #-#]`, (match) => {\n        let subtrahend = 0;\n        const prevLine = `[#-# : ${index - 1} : ${convert.line[index - 1]} : #-#]`;\n\n        /**\n         * Arbitratry character, to keep track of the string's length.\n         */\n        indents += '0';\n        \n        if (index === 0) subtrahend++;\n\n        /* We're processing a closing tag. */\n        if (match.indexOf(`#-# : ${index} : </`) > -1) subtrahend++;\n\n        /* prevLine is a doctype declaration. */\n        if (prevLine.indexOf('<!doctype') > -1) subtrahend++;\n\n        /* prevLine is a comment. */\n        if (prevLine.indexOf('<!--') > -1) subtrahend++;\n\n        /* prevLine is a self-closing tag. */\n        if (prevLine.indexOf('/> : #-#') > -1) subtrahend++;\n\n        /* prevLine is a closing tag. */\n        if (prevLine.indexOf(`#-# : ${index - 1} : </`) > -1) subtrahend++;\n\n        /* Determine offset for line indentation. */\n        const offset = indents.length - subtrahend;\n\n        /* Adjust for the next round. */\n        indents = indents.substring(0, offset);\n\n        /* Remove comment. */\n        if (strict && match.indexOf('<!--') > -1) return ''\n\n        /* Remove the prefix and suffix, leaving the content. */\n        const result = match\n          .replace(`[#-# : ${index} : `, '')\n          .replace(' : #-#]', '');\n\n        /* Pad the string with spaces and return. */\n        return result.padStart(result.length + (step * offset))\n      });\n  });\n\n  /* Remove line returns, tabs, and consecutive spaces within html elements or their content. */\n  html = html.replace(/>[^<]*?[^><\\/\\s][^<]*?<\\/|>\\s+[^><\\s]|<script[^>]*>\\s+<\\/script>|<(\\w+)>\\s+<\\/(\\w+)|<([\\w\\-]+)[^>]*[^\\/]>\\s+<\\/([\\w\\-]+)>/g,\n    match => match.replace(/\\n|\\t|\\s{2,}/g, '')\n  );\n\n  /* Remove self-closing nature of void elements. */\n  if (strict) html = html.replace(/\\s\\/>/g, '>');\n\n  const lead_newline_check = html.substring(0, 1);\n  const tail_newline_check = html.substring(html.length - 1);\n\n  /**\n   * Remove single leading and trailing new line, if they exist.\n   * These will be `false` if the \"html\" being processed is only plain text. \n   */\n  if (lead_newline_check === '\\n') html = html.substring(1, html.length);\n  if (tail_newline_check === '\\n') html = html.substring(0, html.length - 1);\n\n  return html\n};\n\n/**\n * Format HTML with line returns and indentations.\n * \n * @param {string} html The HTML string to prettify.\n * @param {import('htmlfy').UserConfig} [config] A user configuration object.\n * @returns {string} A well-formed HTML string.\n */\nconst prettify = (html, config) => {\n  /* Return content as-is if it does not contain any HTML elements. */\n  if (!isHtml(html)) return html\n\n  const validated_config = config ? validateConfig(config) : CONFIG;\n  strict = validated_config.strict;\n\n  const ignore = validated_config.ignore.length > 0;\n  trim = validated_config.trim;\n\n  /* Protect ignored elements. */\n  if (ignore) {\n    html = ignoreElement(html, validated_config.ignore);\n  }\n\n  html = preprocess(html);\n  html = process(html, validated_config.tab_size);\n\n  /* Unprotect ignored elements. */\n  if (ignore) {\n    html = ignoreElement(html, validated_config.ignore, 'unprotect');\n  }\n\n  return html\n};\n\n// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nexport { prettify as default };\n"],"names":["CONFIG","ignore","strict","tab_size","trim","isHtml","content","test","mergeObjects","current","updates","Error","merged","Array","isArray","structuredClone","concat","key","Object","keys","ignoreElement","html","mode","e","length","regex","RegExp","replace","protectElement","unprotectElement","match","capture","validateConfig","config","hasOwn","Number","isSafeInteger","Math","floor","_config$ignore","every","_config$trim","dconfig","mergeConfig","void_elements","entify","minify","convert","line","preprocess","name","indexOf","substring","closify","leading_whitespace","trailing_whitespace","trimify","i","push","enqueue","validated_config","step","indents","forEach","source","index","subtrahend","prevLine","offset","result","padStart","lead_newline_check","tail_newline_check","process"],"mappings":"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"}